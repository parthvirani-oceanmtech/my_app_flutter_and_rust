// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'convolution.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Convolution {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConvolutionCopyWith<$Res> {
  factory $ConvolutionCopyWith(
          Convolution value, $Res Function(Convolution) then) =
      _$ConvolutionCopyWithImpl<$Res, Convolution>;
}

/// @nodoc
class _$ConvolutionCopyWithImpl<$Res, $Val extends Convolution>
    implements $ConvolutionCopyWith<$Res> {
  _$ConvolutionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ConvolutionBoxBlurImplCopyWith<$Res> {
  factory _$$ConvolutionBoxBlurImplCopyWith(_$ConvolutionBoxBlurImpl value,
          $Res Function(_$ConvolutionBoxBlurImpl) then) =
      __$$ConvolutionBoxBlurImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionBoxBlurImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionBoxBlurImpl>
    implements _$$ConvolutionBoxBlurImplCopyWith<$Res> {
  __$$ConvolutionBoxBlurImplCopyWithImpl(_$ConvolutionBoxBlurImpl _value,
      $Res Function(_$ConvolutionBoxBlurImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionBoxBlurImpl extends ConvolutionBoxBlur {
  const _$ConvolutionBoxBlurImpl() : super._();

  @override
  String toString() {
    return 'Convolution.boxBlur()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvolutionBoxBlurImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return boxBlur();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return boxBlur?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (boxBlur != null) {
      return boxBlur();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return boxBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return boxBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (boxBlur != null) {
      return boxBlur(this);
    }
    return orElse();
  }
}

abstract class ConvolutionBoxBlur extends Convolution implements Filter {
  const factory ConvolutionBoxBlur() = _$ConvolutionBoxBlurImpl;
  const ConvolutionBoxBlur._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionDetect45DegLinesImplCopyWith<$Res> {
  factory _$$ConvolutionDetect45DegLinesImplCopyWith(
          _$ConvolutionDetect45DegLinesImpl value,
          $Res Function(_$ConvolutionDetect45DegLinesImpl) then) =
      __$$ConvolutionDetect45DegLinesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionDetect45DegLinesImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionDetect45DegLinesImpl>
    implements _$$ConvolutionDetect45DegLinesImplCopyWith<$Res> {
  __$$ConvolutionDetect45DegLinesImplCopyWithImpl(
      _$ConvolutionDetect45DegLinesImpl _value,
      $Res Function(_$ConvolutionDetect45DegLinesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionDetect45DegLinesImpl extends ConvolutionDetect45DegLines {
  const _$ConvolutionDetect45DegLinesImpl() : super._();

  @override
  String toString() {
    return 'Convolution.detect45DegLines()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionDetect45DegLinesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detect45DegLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return detect45DegLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect45DegLines != null) {
      return detect45DegLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detect45DegLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detect45DegLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect45DegLines != null) {
      return detect45DegLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetect45DegLines extends Convolution
    implements Filter {
  const factory ConvolutionDetect45DegLines() =
      _$ConvolutionDetect45DegLinesImpl;
  const ConvolutionDetect45DegLines._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionDetect135DegLinesImplCopyWith<$Res> {
  factory _$$ConvolutionDetect135DegLinesImplCopyWith(
          _$ConvolutionDetect135DegLinesImpl value,
          $Res Function(_$ConvolutionDetect135DegLinesImpl) then) =
      __$$ConvolutionDetect135DegLinesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionDetect135DegLinesImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionDetect135DegLinesImpl>
    implements _$$ConvolutionDetect135DegLinesImplCopyWith<$Res> {
  __$$ConvolutionDetect135DegLinesImplCopyWithImpl(
      _$ConvolutionDetect135DegLinesImpl _value,
      $Res Function(_$ConvolutionDetect135DegLinesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionDetect135DegLinesImpl extends ConvolutionDetect135DegLines {
  const _$ConvolutionDetect135DegLinesImpl() : super._();

  @override
  String toString() {
    return 'Convolution.detect135DegLines()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionDetect135DegLinesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detect135DegLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return detect135DegLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect135DegLines != null) {
      return detect135DegLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detect135DegLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detect135DegLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect135DegLines != null) {
      return detect135DegLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetect135DegLines extends Convolution
    implements Filter {
  const factory ConvolutionDetect135DegLines() =
      _$ConvolutionDetect135DegLinesImpl;
  const ConvolutionDetect135DegLines._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionDetectVerticalLinesImplCopyWith<$Res> {
  factory _$$ConvolutionDetectVerticalLinesImplCopyWith(
          _$ConvolutionDetectVerticalLinesImpl value,
          $Res Function(_$ConvolutionDetectVerticalLinesImpl) then) =
      __$$ConvolutionDetectVerticalLinesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionDetectVerticalLinesImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res,
        _$ConvolutionDetectVerticalLinesImpl>
    implements _$$ConvolutionDetectVerticalLinesImplCopyWith<$Res> {
  __$$ConvolutionDetectVerticalLinesImplCopyWithImpl(
      _$ConvolutionDetectVerticalLinesImpl _value,
      $Res Function(_$ConvolutionDetectVerticalLinesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionDetectVerticalLinesImpl
    extends ConvolutionDetectVerticalLines {
  const _$ConvolutionDetectVerticalLinesImpl() : super._();

  @override
  String toString() {
    return 'Convolution.detectVerticalLines()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionDetectVerticalLinesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detectVerticalLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return detectVerticalLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectVerticalLines != null) {
      return detectVerticalLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detectVerticalLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detectVerticalLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectVerticalLines != null) {
      return detectVerticalLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetectVerticalLines extends Convolution
    implements Filter {
  const factory ConvolutionDetectVerticalLines() =
      _$ConvolutionDetectVerticalLinesImpl;
  const ConvolutionDetectVerticalLines._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionDetectHorizontalLinesImplCopyWith<$Res> {
  factory _$$ConvolutionDetectHorizontalLinesImplCopyWith(
          _$ConvolutionDetectHorizontalLinesImpl value,
          $Res Function(_$ConvolutionDetectHorizontalLinesImpl) then) =
      __$$ConvolutionDetectHorizontalLinesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionDetectHorizontalLinesImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res,
        _$ConvolutionDetectHorizontalLinesImpl>
    implements _$$ConvolutionDetectHorizontalLinesImplCopyWith<$Res> {
  __$$ConvolutionDetectHorizontalLinesImplCopyWithImpl(
      _$ConvolutionDetectHorizontalLinesImpl _value,
      $Res Function(_$ConvolutionDetectHorizontalLinesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionDetectHorizontalLinesImpl
    extends ConvolutionDetectHorizontalLines {
  const _$ConvolutionDetectHorizontalLinesImpl() : super._();

  @override
  String toString() {
    return 'Convolution.detectHorizontalLines()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionDetectHorizontalLinesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detectHorizontalLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return detectHorizontalLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectHorizontalLines != null) {
      return detectHorizontalLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detectHorizontalLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detectHorizontalLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectHorizontalLines != null) {
      return detectHorizontalLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetectHorizontalLines extends Convolution
    implements Filter {
  const factory ConvolutionDetectHorizontalLines() =
      _$ConvolutionDetectHorizontalLinesImpl;
  const ConvolutionDetectHorizontalLines._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionEdgeDetectionImplCopyWith<$Res> {
  factory _$$ConvolutionEdgeDetectionImplCopyWith(
          _$ConvolutionEdgeDetectionImpl value,
          $Res Function(_$ConvolutionEdgeDetectionImpl) then) =
      __$$ConvolutionEdgeDetectionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionEdgeDetectionImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionEdgeDetectionImpl>
    implements _$$ConvolutionEdgeDetectionImplCopyWith<$Res> {
  __$$ConvolutionEdgeDetectionImplCopyWithImpl(
      _$ConvolutionEdgeDetectionImpl _value,
      $Res Function(_$ConvolutionEdgeDetectionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionEdgeDetectionImpl extends ConvolutionEdgeDetection {
  const _$ConvolutionEdgeDetectionImpl() : super._();

  @override
  String toString() {
    return 'Convolution.edgeDetection()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionEdgeDetectionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return edgeDetection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return edgeDetection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeDetection != null) {
      return edgeDetection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return edgeDetection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return edgeDetection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeDetection != null) {
      return edgeDetection(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEdgeDetection extends Convolution implements Filter {
  const factory ConvolutionEdgeDetection() = _$ConvolutionEdgeDetectionImpl;
  const ConvolutionEdgeDetection._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionEdgeOneImplCopyWith<$Res> {
  factory _$$ConvolutionEdgeOneImplCopyWith(_$ConvolutionEdgeOneImpl value,
          $Res Function(_$ConvolutionEdgeOneImpl) then) =
      __$$ConvolutionEdgeOneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionEdgeOneImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionEdgeOneImpl>
    implements _$$ConvolutionEdgeOneImplCopyWith<$Res> {
  __$$ConvolutionEdgeOneImplCopyWithImpl(_$ConvolutionEdgeOneImpl _value,
      $Res Function(_$ConvolutionEdgeOneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionEdgeOneImpl extends ConvolutionEdgeOne {
  const _$ConvolutionEdgeOneImpl() : super._();

  @override
  String toString() {
    return 'Convolution.edgeOne()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvolutionEdgeOneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return edgeOne();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return edgeOne?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeOne != null) {
      return edgeOne();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return edgeOne(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return edgeOne?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeOne != null) {
      return edgeOne(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEdgeOne extends Convolution implements Filter {
  const factory ConvolutionEdgeOne() = _$ConvolutionEdgeOneImpl;
  const ConvolutionEdgeOne._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionEmbossImplCopyWith<$Res> {
  factory _$$ConvolutionEmbossImplCopyWith(_$ConvolutionEmbossImpl value,
          $Res Function(_$ConvolutionEmbossImpl) then) =
      __$$ConvolutionEmbossImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionEmbossImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionEmbossImpl>
    implements _$$ConvolutionEmbossImplCopyWith<$Res> {
  __$$ConvolutionEmbossImplCopyWithImpl(_$ConvolutionEmbossImpl _value,
      $Res Function(_$ConvolutionEmbossImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionEmbossImpl extends ConvolutionEmboss {
  const _$ConvolutionEmbossImpl() : super._();

  @override
  String toString() {
    return 'Convolution.emboss()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvolutionEmbossImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return emboss();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return emboss?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (emboss != null) {
      return emboss();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return emboss(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return emboss?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (emboss != null) {
      return emboss(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEmboss extends Convolution implements Filter {
  const factory ConvolutionEmboss() = _$ConvolutionEmbossImpl;
  const ConvolutionEmboss._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionIdentityImplCopyWith<$Res> {
  factory _$$ConvolutionIdentityImplCopyWith(_$ConvolutionIdentityImpl value,
          $Res Function(_$ConvolutionIdentityImpl) then) =
      __$$ConvolutionIdentityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionIdentityImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionIdentityImpl>
    implements _$$ConvolutionIdentityImplCopyWith<$Res> {
  __$$ConvolutionIdentityImplCopyWithImpl(_$ConvolutionIdentityImpl _value,
      $Res Function(_$ConvolutionIdentityImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionIdentityImpl extends ConvolutionIdentity {
  const _$ConvolutionIdentityImpl() : super._();

  @override
  String toString() {
    return 'Convolution.identity()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionIdentityImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return identity();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return identity?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (identity != null) {
      return identity();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return identity(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return identity?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (identity != null) {
      return identity(this);
    }
    return orElse();
  }
}

abstract class ConvolutionIdentity extends Convolution implements Filter {
  const factory ConvolutionIdentity() = _$ConvolutionIdentityImpl;
  const ConvolutionIdentity._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionLaplaceImplCopyWith<$Res> {
  factory _$$ConvolutionLaplaceImplCopyWith(_$ConvolutionLaplaceImpl value,
          $Res Function(_$ConvolutionLaplaceImpl) then) =
      __$$ConvolutionLaplaceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionLaplaceImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionLaplaceImpl>
    implements _$$ConvolutionLaplaceImplCopyWith<$Res> {
  __$$ConvolutionLaplaceImplCopyWithImpl(_$ConvolutionLaplaceImpl _value,
      $Res Function(_$ConvolutionLaplaceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionLaplaceImpl extends ConvolutionLaplace {
  const _$ConvolutionLaplaceImpl() : super._();

  @override
  String toString() {
    return 'Convolution.laplace()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvolutionLaplaceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return laplace();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return laplace?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (laplace != null) {
      return laplace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return laplace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return laplace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (laplace != null) {
      return laplace(this);
    }
    return orElse();
  }
}

abstract class ConvolutionLaplace extends Convolution implements Filter {
  const factory ConvolutionLaplace() = _$ConvolutionLaplaceImpl;
  const ConvolutionLaplace._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionNoiseReductionImplCopyWith<$Res> {
  factory _$$ConvolutionNoiseReductionImplCopyWith(
          _$ConvolutionNoiseReductionImpl value,
          $Res Function(_$ConvolutionNoiseReductionImpl) then) =
      __$$ConvolutionNoiseReductionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionNoiseReductionImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionNoiseReductionImpl>
    implements _$$ConvolutionNoiseReductionImplCopyWith<$Res> {
  __$$ConvolutionNoiseReductionImplCopyWithImpl(
      _$ConvolutionNoiseReductionImpl _value,
      $Res Function(_$ConvolutionNoiseReductionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionNoiseReductionImpl extends ConvolutionNoiseReduction {
  const _$ConvolutionNoiseReductionImpl() : super._();

  @override
  String toString() {
    return 'Convolution.noiseReduction()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionNoiseReductionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return noiseReduction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return noiseReduction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (noiseReduction != null) {
      return noiseReduction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return noiseReduction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return noiseReduction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (noiseReduction != null) {
      return noiseReduction(this);
    }
    return orElse();
  }
}

abstract class ConvolutionNoiseReduction extends Convolution implements Filter {
  const factory ConvolutionNoiseReduction() = _$ConvolutionNoiseReductionImpl;
  const ConvolutionNoiseReduction._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionPrewittHorizontalImplCopyWith<$Res> {
  factory _$$ConvolutionPrewittHorizontalImplCopyWith(
          _$ConvolutionPrewittHorizontalImpl value,
          $Res Function(_$ConvolutionPrewittHorizontalImpl) then) =
      __$$ConvolutionPrewittHorizontalImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionPrewittHorizontalImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionPrewittHorizontalImpl>
    implements _$$ConvolutionPrewittHorizontalImplCopyWith<$Res> {
  __$$ConvolutionPrewittHorizontalImplCopyWithImpl(
      _$ConvolutionPrewittHorizontalImpl _value,
      $Res Function(_$ConvolutionPrewittHorizontalImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionPrewittHorizontalImpl extends ConvolutionPrewittHorizontal {
  const _$ConvolutionPrewittHorizontalImpl() : super._();

  @override
  String toString() {
    return 'Convolution.prewittHorizontal()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionPrewittHorizontalImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return prewittHorizontal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return prewittHorizontal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (prewittHorizontal != null) {
      return prewittHorizontal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return prewittHorizontal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return prewittHorizontal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (prewittHorizontal != null) {
      return prewittHorizontal(this);
    }
    return orElse();
  }
}

abstract class ConvolutionPrewittHorizontal extends Convolution
    implements Filter {
  const factory ConvolutionPrewittHorizontal() =
      _$ConvolutionPrewittHorizontalImpl;
  const ConvolutionPrewittHorizontal._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionSharpenImplCopyWith<$Res> {
  factory _$$ConvolutionSharpenImplCopyWith(_$ConvolutionSharpenImpl value,
          $Res Function(_$ConvolutionSharpenImpl) then) =
      __$$ConvolutionSharpenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionSharpenImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionSharpenImpl>
    implements _$$ConvolutionSharpenImplCopyWith<$Res> {
  __$$ConvolutionSharpenImplCopyWithImpl(_$ConvolutionSharpenImpl _value,
      $Res Function(_$ConvolutionSharpenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionSharpenImpl extends ConvolutionSharpen {
  const _$ConvolutionSharpenImpl() : super._();

  @override
  String toString() {
    return 'Convolution.sharpen()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvolutionSharpenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sharpen();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return sharpen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sharpen != null) {
      return sharpen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sharpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sharpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sharpen != null) {
      return sharpen(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSharpen extends Convolution implements Filter {
  const factory ConvolutionSharpen() = _$ConvolutionSharpenImpl;
  const ConvolutionSharpen._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionSobelHorizontalImplCopyWith<$Res> {
  factory _$$ConvolutionSobelHorizontalImplCopyWith(
          _$ConvolutionSobelHorizontalImpl value,
          $Res Function(_$ConvolutionSobelHorizontalImpl) then) =
      __$$ConvolutionSobelHorizontalImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionSobelHorizontalImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionSobelHorizontalImpl>
    implements _$$ConvolutionSobelHorizontalImplCopyWith<$Res> {
  __$$ConvolutionSobelHorizontalImplCopyWithImpl(
      _$ConvolutionSobelHorizontalImpl _value,
      $Res Function(_$ConvolutionSobelHorizontalImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionSobelHorizontalImpl extends ConvolutionSobelHorizontal {
  const _$ConvolutionSobelHorizontalImpl() : super._();

  @override
  String toString() {
    return 'Convolution.sobelHorizontal()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionSobelHorizontalImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sobelHorizontal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return sobelHorizontal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelHorizontal != null) {
      return sobelHorizontal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sobelHorizontal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sobelHorizontal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelHorizontal != null) {
      return sobelHorizontal(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSobelHorizontal extends Convolution
    implements Filter {
  const factory ConvolutionSobelHorizontal() = _$ConvolutionSobelHorizontalImpl;
  const ConvolutionSobelHorizontal._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionSobelVerticalImplCopyWith<$Res> {
  factory _$$ConvolutionSobelVerticalImplCopyWith(
          _$ConvolutionSobelVerticalImpl value,
          $Res Function(_$ConvolutionSobelVerticalImpl) then) =
      __$$ConvolutionSobelVerticalImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvolutionSobelVerticalImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionSobelVerticalImpl>
    implements _$$ConvolutionSobelVerticalImplCopyWith<$Res> {
  __$$ConvolutionSobelVerticalImplCopyWithImpl(
      _$ConvolutionSobelVerticalImpl _value,
      $Res Function(_$ConvolutionSobelVerticalImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConvolutionSobelVerticalImpl extends ConvolutionSobelVertical {
  const _$ConvolutionSobelVerticalImpl() : super._();

  @override
  String toString() {
    return 'Convolution.sobelVertical()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionSobelVerticalImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sobelVertical();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return sobelVertical?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelVertical != null) {
      return sobelVertical();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sobelVertical(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sobelVertical?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelVertical != null) {
      return sobelVertical(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSobelVertical extends Convolution implements Filter {
  const factory ConvolutionSobelVertical() = _$ConvolutionSobelVerticalImpl;
  const ConvolutionSobelVertical._() : super._();
}

/// @nodoc
abstract class _$$ConvolutionGaussianBlurImplCopyWith<$Res> {
  factory _$$ConvolutionGaussianBlurImplCopyWith(
          _$ConvolutionGaussianBlurImpl value,
          $Res Function(_$ConvolutionGaussianBlurImpl) then) =
      __$$ConvolutionGaussianBlurImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int radius});
}

/// @nodoc
class __$$ConvolutionGaussianBlurImplCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res, _$ConvolutionGaussianBlurImpl>
    implements _$$ConvolutionGaussianBlurImplCopyWith<$Res> {
  __$$ConvolutionGaussianBlurImplCopyWithImpl(
      _$ConvolutionGaussianBlurImpl _value,
      $Res Function(_$ConvolutionGaussianBlurImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? radius = null,
  }) {
    return _then(_$ConvolutionGaussianBlurImpl(
      radius: null == radius
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ConvolutionGaussianBlurImpl extends ConvolutionGaussianBlur {
  const _$ConvolutionGaussianBlurImpl({required this.radius}) : super._();

  @override
  final int radius;

  @override
  String toString() {
    return 'Convolution.gaussianBlur(radius: $radius)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvolutionGaussianBlurImpl &&
            (identical(other.radius, radius) || other.radius == radius));
  }

  @override
  int get hashCode => Object.hash(runtimeType, radius);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvolutionGaussianBlurImplCopyWith<_$ConvolutionGaussianBlurImpl>
      get copyWith => __$$ConvolutionGaussianBlurImplCopyWithImpl<
          _$ConvolutionGaussianBlurImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return gaussianBlur(radius);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boxBlur,
    TResult? Function()? detect45DegLines,
    TResult? Function()? detect135DegLines,
    TResult? Function()? detectVerticalLines,
    TResult? Function()? detectHorizontalLines,
    TResult? Function()? edgeDetection,
    TResult? Function()? edgeOne,
    TResult? Function()? emboss,
    TResult? Function()? identity,
    TResult? Function()? laplace,
    TResult? Function()? noiseReduction,
    TResult? Function()? prewittHorizontal,
    TResult? Function()? sharpen,
    TResult? Function()? sobelHorizontal,
    TResult? Function()? sobelVertical,
    TResult? Function(int radius)? gaussianBlur,
  }) {
    return gaussianBlur?.call(radius);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (gaussianBlur != null) {
      return gaussianBlur(radius);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return gaussianBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvolutionBoxBlur value)? boxBlur,
    TResult? Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult? Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult? Function(ConvolutionDetectVerticalLines value)?
        detectVerticalLines,
    TResult? Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult? Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult? Function(ConvolutionEdgeOne value)? edgeOne,
    TResult? Function(ConvolutionEmboss value)? emboss,
    TResult? Function(ConvolutionIdentity value)? identity,
    TResult? Function(ConvolutionLaplace value)? laplace,
    TResult? Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult? Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult? Function(ConvolutionSharpen value)? sharpen,
    TResult? Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult? Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult? Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return gaussianBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (gaussianBlur != null) {
      return gaussianBlur(this);
    }
    return orElse();
  }
}

abstract class ConvolutionGaussianBlur extends Convolution implements Filter {
  const factory ConvolutionGaussianBlur({required final int radius}) =
      _$ConvolutionGaussianBlurImpl;
  const ConvolutionGaussianBlur._() : super._();

  int get radius;
  @JsonKey(ignore: true)
  _$$ConvolutionGaussianBlurImplCopyWith<_$ConvolutionGaussianBlurImpl>
      get copyWith => throw _privateConstructorUsedError;
}
